NewType<CategoryType>;

// src/theme.ts
import { ThemeProvider } from 'styled-components';
import {
  createGlobalStyle,
  DefaultTheme,
  ThemeProvider as StyledThemeProvider,
} from 'styled-components';
import { useMemo } from 'react';

// Define the light theme
const lightTheme: DefaultTheme = {
  name: 'light',
  colors: {
    primary: '#6200ee',
    primaryVariant: '#3700b3',
    secondary: '#03dac6',
    background: '#ffffff',
    surface: '#f5f5f5',
    error: '#b00020',
    textOnPrimary: '#ffffff',
    textOnBackground: '#000000',
    textOnSurface: '#000000',
    textOnError: '#ffffff',
  },
};

// Define the dark theme
const darkTheme: DefaultTheme = {
  name: 'dark',
  colors: {
    primary: '#bb86fc',
    primaryVariant: '#3700b3',
    secondary: '#03dac6',
    background: '#121212',
    surface: '#333333',
    error: '#cf6679',
    textOnPrimary: '#000000',
    textOnBackground: '#ffffff',
    textOnSurface: '#ffffff',
    textOnError: '#000000',
  },
};

// Define the theme interface
export interface ITheme extends DefaultTheme {
  // ... add any additional theme properties here
}

// Global styles
export const GlobalStyles = createGlobalStyle`
  *, *::before, *::after {
    box-sizing: border-box;
  }
  body {
    margin: 0;
    font-family: Roboto, sans-serif;
    background-color: ${(props: ThemeProviderProps) => props.theme.colors.background};
    color: ${(props: ThemeProviderProps) => props.theme.colors.textOnBackground};
  }

  a {
    color: inherit;
    text-decoration: none;
  }

  button {
    touch-action: manipulation;
    user-select: none;
    cursor: pointer;
    outline: none;
  }
`;

// Theme provider props
interface ThemeProviderProps {
  children: JSX.Element;
}

// Theme provider component
const ThemeProvider: React.FC<ThemeProviderProps & { themeMode: ThemeMode }> = ({ children, themeMode }) => {
  // Memoize theme to avoid re-renders
  const theme = useMemo(() => (themeMode === ThemeMode.Light ? lightTheme : darkTheme), [themeMode]);

  return (
    <StyledThemeProvider theme={theme}>
      <>
        <GlobalStyles />
        {children}
      </>
    </StyledThemeProvider>
  );
};

export default ThemeProvider;

// src/LanguageSelector.tsx
import React, { useRef, useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { CATEGORY, Locale, Language, CategoryName, useLocale } from './I18n';

interface LanguageSelectorProps {
  onLanguageChange?: (newLocale: Locale) => void;
}

const SPlayground: typeof playYouTubeOnLKIcon = {} as unknown as typeof playYouTubeOnLKIcon;

export const LanguageSelector: React.FC<LanguageSelectorProps> = ({ onLanguageChange }) => {
  const { locale: selectedLanguage, setLocale } = useLocale();
  const [isOpen, setIsOpen] = useState<boolean>(false);
  const stackRef = useRef<HTMLUListElement>(null);
  const menuRef = useRef<HTMLDivElement>(null);
  const dropdownRef = useRef<HTMLButtonElement>(null);

  const closeAll = useCallback(() => {
    setIsOpen(false);
  }, []);

  const closeMenu = () => {
    if (isOpen) closeAll();
  };

  // Close when escape key is pressed
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.code === 'Escape') closeAll();
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
    };
  }, [closeAll]);

  const menuPressed = (lang: string, event: React.MouseEvent<HTMLButtonElement>) => {
    selectLanguage(lang as Locale, event);
  };

  const toggle = (event: React.MouseEvent<HTMLButtonElement>) => {
    setIsOpen((s) => !s);
    event.stopPropagation();
  };

  const selectLanguage = (lang: Locale, ev: React.MouseEvent) => {
    setLocale(lang);
    ev.stopPropagation();
    if (lang !== selectedLanguage) {
      closeAll();
    }
    if (onLanguageChange) onLanguageChange(lang);
  };

  const buttonLocale = (lang: Locale) => `${locales[lang]?.